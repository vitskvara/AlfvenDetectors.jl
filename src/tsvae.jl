"""
	TSVAE{m1, m2}

Flux-like structure for the two-stage variational autoencoder.
"""
struct TSVAE <: FluxModel
	m1::VAE
	m2::VAE
end

(tsvae::TSVAE)(X) = tsvae.m1(X)

# is this necesarry?
Flux.@treelike TSVAE #encoder, decoder

"""
	TSVAE(m1size, m2size; [activation, layer])

Initialize a variational autoencoder with given encoder size and decoder size.

m1size - a tuple of two vectors specifying the size of model 1
m2size - a tuple of two vectors specifying the size of model 2
activation [Flux.relu] - arbitrary activation function
layer [Flux.Dense] - type of layer
"""
function TSVAE(m1size::AbstractVector, m2size::AbstractVector; 
	activation = Flux.relu,	layer = Flux.Dense)
	@assert m1size[2][1] == m2size[1][1]

	# construct models
	m1 = VAE(m1size[1], m1size[2], activation=activation, layer=layer,
		variant = :scalar)
	m2 = VAE(m2size[1], m2size[2], activation=activation, layer=layer,
		variant = :scalar)
	
	return TSVAE(m1,m2)
end

"""
	TSVAE(xdim, latentdim, nlayers; [activation, layer])

A lightweight constructor for TSVAE.
"""
function TSVAE(xdim::Int, zdim::Int, nlayers::Union{Int, Tuple}; 
	activation = Flux.relu,	layer = Flux.Dense)
	# if nlayers is scalar (both nets are to be the same depth)
	# create a tuple anyway
	nlayers = scalar2vec(nlayers)

	m1 = VAE(xdim, zdim, nlayers[1]; activation=activation, layer=layer,
		variant=:scalar)
	m2 = VAE(zdim, zdim, nlayers[2]; activation=activation, layer=layer,
		variant=:scalar)
	return TSVAE(m1,m2)
end

"""
	ConvTSVAE(insize, latentdim, nconv, kernelsize, channels, scaling; 
		[variant, ndense, dsizes, activation, stride])

Initializes a two stage variational autoencoder with convolutional first stage.
"""
function ConvTSVAE(insize, latentdim, nlayers::Union{Int, Tuple}, kernelsize, channels, scaling; 
	kwargs...)
	nlayers = scalar2vec(nlayers)
	
	m1 = ConvVAE(insize, latentdim, nlayers[1], kernelsize, channels, scaling; variant = :scalar,
		kwargs...)
	m2 = VAE(latentdim, latentdim, nlayers[2]; variant = :scalar, kwargs...)
	return TSVAE(m1,m2)
end


"""
	getlosses(tsvae, X, L, β)

Return the numeric values of current losses as a tuple.
"""
function getlosses(tsvae::TSVAE, X, L, β) 
	m1ls = getlosses(tsvae.m1, X, L, β)
	Z = tsvae.m1.sampler(tsvae.m1.encoder(X))
	m2ls = getlosses(tsvae.m2, Z, L, β)
	return m1ls, m2ls
end

"""
	fit!(tsvae::TSVAE, X, batchsize::Union{Int, Tuple}, 
	nepochs::Union{Int, Tuple}; 
	L::Union{Int, Tuple}=(1,1), β::Union{Real, Tuple}= Float(1.0), 
	cbit::Union{Int, Tuple}=(200,200), history = nothing, 
	verb::Bool = true, η::Union{Real, Tuple} = (0.001,0.001), 
	runtype = "experimental", [usegpu, memoryefficient])

Fit the two-stage VAE model.
"""
function fit!(tsvae::TSVAE, X, batchsize::Union{Int, Tuple}, 
	nepochs::Union{Int, Tuple}; 
	L::Union{Int, Tuple}=(1,1), β::Union{Real, Tuple}= Float(1.0), 
	cbit::Union{Int, Tuple}=(200,200), history = nothing, 
	verb::Bool = true, η::Union{Real, Tuple} = (0.001,0.001), 
	runtype = "experimental", opt=nothing, trainkwargs...)
	@assert runtype in ["experimental", "fast"]

	# some argument may be scalar or a tuple
	# this will convert them all to tuples
	batchsize = scalar2vec(batchsize)
	nepochs = scalar2vec(nepochs)
	L = scalar2vec(L)
	β = scalar2vec(β)
	cbit = scalar2vec(cbit)
	history = scalar2vec(history)
	η = scalar2vec(η)
	opt = scalar2vec(opt)

	if verb
		println("Training the first stage...")
	end
	opt[1] = fit!(tsvae.m1, X, batchsize[1], nepochs[1]; L = L[1], β = β[1], cbit=cbit[1], opt=opt[1],
		history = history[1], verb = verb, η = η[1], runtype = runtype, trainkwargs...)
	
	if verb
		println("Training the second stage...")
	end
	# this is in case taht X is already on gpu -> Z is on gpu as well
	if iscuarray(X)
		Z = tsvae.m1.sampler(tsvae.m1.encoder(X).data)
	else
		Z = tsvae.m1.sampler(cpu(tsvae.m1.encoder)(X).data)
	end
	opt[2] = fit!(tsvae.m2, Z, batchsize[2], nepochs[2]; L = L[2], β = β[2], cbit=cbit[2], opt=opt[2],
		history = history[2], verb = verb, η = η[2], runtype = runtype, trainkwargs...)
	return opt
end

"""
	sample(tsvae::TSVAE, [M::Int])

Get samples generated by the TSVAE.
"""
function StatsBase.sample(tsvae::TSVAE)
	samplenormal_scalarvar(tsvae.m1.decoder(sample(tsvae.m2)))
end
function StatsBase.sample(tsvae::TSVAE, M::Int)
	samplenormal_scalarvar(tsvae.m1.decoder(sample(tsvae.m2,M)))
end
